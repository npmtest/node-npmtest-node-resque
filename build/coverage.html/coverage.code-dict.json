{"/home/travis/build/npmtest/node-npmtest-node-resque/test.js":"/* istanbul instrument in package npmtest_node_resque */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-resque/lib.npmtest_node_resque.js":"/* istanbul instrument in package npmtest_node_resque */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_resque = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_resque = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-resque/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-resque && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_resque */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_resque\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_resque.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_resque.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_resque.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_resque.__dirname + '/lib.npmtest_node_resque.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/index.js":"exports.connection     = require(__dirname + '/lib/connection.js').connection;\nexports.queue          = require(__dirname + '/lib/queue.js').queue;\nexports.worker         = require(__dirname + '/lib/worker.js').worker;\nexports.multiWorker    = require(__dirname + '/lib/multiWorker.js').multiWorker;\nexports.scheduler      = require(__dirname + '/lib/scheduler.js').scheduler;\nexports.pluginRunner   = require(__dirname + '/lib/pluginRunner.js');\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/connection.js":"var util  = require('util');\nvar async = require('async');\nvar EventEmitter = require('events').EventEmitter;\n\nvar connection = function(options){\n  var self = this;\n  var defaults = self.defaults();\n\n  if(!options){ options = {}; }\n  for(var i in defaults){\n    if(options[i] === null || options[i] === undefined){\n      options[i] = defaults[i];\n    }\n  }\n  self.options = options;\n  self.listeners = {};\n  self.connected = false;\n};\n\nutil.inherits(connection, EventEmitter);\n\nconnection.prototype.defaults = function(){\n  return {\n    pkg:       'ioredis',\n    host:      '127.0.0.1',\n    port:      6379,\n    database:  0,\n    namespace: 'resque',\n  };\n};\n\nconnection.prototype.connect = function(callback){\n  var self = this;\n\n  if(self.options.redis){\n    var jobs = [];\n    self.redis = self.options.redis;\n\n    jobs.push(function(done){\n      self.redis.set(self.key('connection_test_key'), 'true', done);\n    });\n\n    jobs.push(function(done){\n      self.redis.get(self.key('connection_test_key'), function(error, data){\n        if(!error && data !== 'true'){ error = new Error('cannot read connection test key'); }\n        if(error){\n          self.connected = false;\n          self.emit('error', error);\n          return done(error);\n        }\n        self.connected = true;\n        done();\n      });\n    });\n\n    async.series(jobs, callback);\n  }else{\n\n    if(self.options['package'] && !self.options.pkg){\n      self.emit('Depreciation warning: You need to use \\'pkg\\' instead of \\'package\\'! Please update your configuration.');\n      self.options.pkg = self.options['package'];\n    }\n    var pkg = require(self.options.pkg);\n    self.redis = pkg.createClient(self.options.port, self.options.host, self.options.options);\n\n    self.listeners.connect = function(){\n      if(self.connected === true){\n        // nothing to do here; this is a reconnect\n      }else{\n        self.redis.select(self.options.database, function(error){\n          if(error){\n            self.connected = false;\n            self.emit('error', error);\n            return callback(error);\n          }else{\n            self.connected = true;\n            return callback();\n          }\n        });\n      }\n    };\n\n    self.redis.on('connect', self.listeners.connect);\n    if(self.options.pkg === 'fakeredis'){ process.nextTick(self.listeners.connect); }\n  }\n\n  self.listeners.error = function(error){ self.emit('error', error); };\n  self.redis.on('error', self.listeners.error);\n\n  self.listeners.end = function(){ self.connected = false; };\n  self.redis.on('end', self.listeners.end);\n};\n\nconnection.prototype.end = function(){\n  var self = this;\n  self.connected = false;\n\n  Object.keys(self.listeners).forEach(function(eventName){\n    self.redis.removeListener(eventName, self.listeners[eventName]);\n  });\n\n  // Only disconnect if we established the redis connection on our own.\n  if(!self.options.redis && self.options.pkg !== 'fakeredis'){\n    if(typeof self.redis.disconnect === 'function'){ self.redis.disconnect(); }\n    else{ self.redis.quit(); }\n  }\n};\n\nconnection.prototype.key = function(){\n  var args;\n  args = (arguments.length >= 1 ? [].slice.call(arguments, 0) : []);\n  args.unshift(this.options.namespace);\n  return args.join(':');\n};\n\nexports.connection = connection;\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/queue.js":"var util         = require('util');\nvar async        = require('async');\nvar EventEmitter = require('events').EventEmitter;\nvar connection   = require(__dirname + '/connection.js').connection;\nvar pluginRunner = require(__dirname + '/pluginRunner.js');\n\nvar queue = function(options, jobs){\n  var self = this;\n  if(!jobs){ jobs = {}; }\n\n  self.options = options;\n  self.jobs    = jobs;\n\n  self.connection = new connection(options.connection);\n\n  self.connection.on('error', function(error){\n    self.emit('error', error);\n  });\n};\n\nutil.inherits(queue, EventEmitter);\n\nqueue.prototype.connect = function(callback){\n  var self = this;\n  self.connection.connect(callback);\n};\n\nqueue.prototype.end = function(callback){\n  var self = this;\n  self.connection.end();\n  return callback();\n};\n\nqueue.prototype.encode = function(q, func, args){\n  return JSON.stringify({\n    'class': func,\n    queue: q,\n    args: args || []\n  });\n};\n\nqueue.prototype.enqueue = function(q, func, args, callback){\n  var self = this;\n  var jobs = [];\n  if(arguments.length === 3 && typeof args === 'function'){\n    callback = args;\n    args = [];\n  }else if(arguments.length < 3){\n    args = [];\n  }\n\n  args = arrayify(args);\n  var job = self.jobs[func];\n\n  pluginRunner.runPlugins(self, 'before_enqueue', func, q, job, args, function(error, toRun){\n    if(error){ return callback(error); }\n    if(toRun === false){ return callback(error, toRun); }\n\n    jobs.push(function(done){\n      self.connection.redis.sadd(self.connection.key('queues'), q, done);\n    });\n\n    jobs.push(function(done){\n      self.connection.redis.rpush(self.connection.key('queue', q), self.encode(q, func, args), done);\n    });\n\n    jobs.push(function(done){\n      pluginRunner.runPlugins(self, 'after_enqueue', func, q, job, args, done);\n    });\n\n    async.series(jobs, callback);\n  });\n};\n\nqueue.prototype.enqueueAt = function(timestamp, q, func, args, callback){\n  // Don't run plugins here, they should be run by scheduler at the enqueue step\n  var self = this;\n  var jobs = [];\n\n  if(arguments.length === 4 && typeof args === 'function'){\n    callback = args;\n    args = [];\n  }else if(arguments.length < 4){\n    args = [];\n  }\n\n  args = arrayify(args);\n  var item = self.encode(q, func, args);\n  var rTimestamp = Math.round(timestamp / 1000); // assume timestamp is in ms\n\n  jobs.push(function(done){\n    // check if this jobs is already enqueued at this time\n    var match = ('delayed:' + rTimestamp);\n    self.connection.redis.smembers(self.connection.key('timestamps:' + item), function(error, members){\n      for(var i in members){\n        if(members[i] === match){\n          return done(new Error('Job already enqueued at this time with same arguments'));\n        }\n      }\n\n      done(error);\n    });\n  });\n\n  jobs.push(function(done){\n    // enqueue the encoded job into a list per timestmp to be popped and workered later\n    self.connection.redis.rpush(self.connection.key('delayed:' + rTimestamp), item, done);\n  });\n\n  jobs.push(function(done){\n    // save the job + args into a set so that it can be checked by plugins\n    self.connection.redis.sadd(self.connection.key('timestamps:' + item), ('delayed:' + rTimestamp), done);\n  });\n\n  jobs.push(function(done){\n    self.connection.redis.zadd(self.connection.key('delayed_queue_schedule'), rTimestamp, rTimestamp, done);\n  });\n\n  async.series(jobs, callback);\n};\n\nqueue.prototype.enqueueIn = function(time, q, func, args, callback){\n  var self = this;\n\n  if(arguments.length === 4 && typeof args === 'function'){\n    callback = args;\n    args = [];\n  }else if(arguments.length < 4){\n    args = [];\n  }\n\n  args = arrayify(args);\n  var timestamp = (new Date().getTime()) + parseInt(time, 10);\n  self.enqueueAt(timestamp, q, func, args, callback);\n};\n\nqueue.prototype.queues = function(callback){\n  var self = this;\n  self.connection.redis.smembers(self.connection.key('queues'), callback);\n};\n\nqueue.prototype.delQueue = function(q, callback){\n  var self = this;\n  self.connection.redis.del(self.connection.key('queue', q), function(error){\n    if(error){ return callback(error); }\n    self.connection.redis.srem(self.connection.key('queues'), q, callback);\n  });\n};\n\nqueue.prototype.length = function(q, callback){\n  var self = this;\n  self.connection.redis.llen(self.connection.key('queue', q), callback);\n};\n\nqueue.prototype.del = function(q, func, args, count, callback){\n  var self = this;\n\n  if(typeof count === 'function' && callback === undefined){\n    callback = count;\n    count = 0;\n  }else if(arguments.length === 3){\n    if(typeof args === 'function'){\n      callback = args;\n      args = [];\n    }\n    count = 0;\n  }else if(arguments.length < 3){\n    args = [];\n    count = 0;\n  }\n\n  args = arrayify(args);\n  self.connection.redis.lrem(self.connection.key('queue', q), count, self.encode(q, func, args), callback);\n};\n\nqueue.prototype.delDelayed = function(q, func, args, callback){\n  var self = this;\n  var jobs = [];\n  var timestamps = [];\n\n  if(arguments.length === 3 && typeof args === 'function'){\n    callback = args;\n    args = [];\n  }else if(arguments.length < 3){\n    args = [];\n  }\n\n  args = arrayify(args);\n  var search = self.encode(q, func, args);\n  var timestamps = [];\n  self.connection.redis.smembers(self.connection.key('timestamps:' + search), function(error, members){\n    if(error){ return callback(error); }\n\n    members.forEach(function(key){\n      jobs.push(function(done){\n        self.connection.redis.lrem(self.connection.key(key), 0, search, function(error, count){\n          if(error){ return done(error); }\n          if(count > 0){\n            timestamps.push(key.split(':')[key.split(':').length - 1]);\n            self.connection.redis.srem(self.connection.key('timestamps:' + search), key, done);\n          }else{\n            done();\n          }\n        });\n      });\n    });\n\n    async.series(jobs, function(error){\n      return callback(error, timestamps);\n    });\n  });\n};\n\nqueue.prototype.scheduledAt = function(q, func, args, callback){\n  var self = this;\n  var timestamps = [];\n\n  if(arguments.length === 3 && typeof args === 'function'){\n    callback = args;\n    args = [];\n  }else if(arguments.length < 3){\n    args = [];\n  }\n  args = arrayify(args);\n  var search = self.encode(q, func, args);\n\n  self.connection.redis.smembers(self.connection.key('timestamps:' + search), function(error, members){\n    if(members !== null){\n      members.forEach(function(key){\n        timestamps.push(key.split(':')[key.split(':').length - 1]);\n      });\n    }\n\n    callback(error, timestamps);\n  });\n};\n\nqueue.prototype.timestamps = function(callback){\n  var self = this;\n  var results = [];\n  self.connection.redis.keys(self.connection.key('delayed:*'), function(error, timestamps){\n    timestamps.forEach(function(timestamp){\n      var parts = timestamp.split(':');\n      results.push(parseInt(parts[(parts.length - 1)]) * 1000);\n    });\n    results.sort();\n    callback(error, results);\n  });\n};\n\nqueue.prototype.delayedAt = function(timestamp, callback){\n  var self = this;\n  var rTimestamp = Math.round(timestamp / 1000); // assume timestamp is in ms\n  self.connection.redis.lrange(self.connection.key('delayed:' + rTimestamp), 0, -1, function(error, items){\n    var tasks = items.map(function(i){ return JSON.parse(i); });\n    callback(error, tasks, rTimestamp);\n  });\n};\n\nqueue.prototype.queued = function(q, start, stop, callback){\n  var self = this;\n  self.connection.redis.lrange(self.connection.key('queue', q), start, stop, function(error, items){\n    var tasks = items.map(function(i){ return JSON.parse(i); });\n    callback(error, tasks);\n  });\n};\n\nqueue.prototype.allDelayed = function(callback){\n  var self = this;\n  var results = {};\n  var jobs = [];\n\n  self.timestamps(function(error, timestamps){\n    if(error){ return callback(error); }\n\n    timestamps.forEach(function(timestamp){\n      jobs.push(function(done){\n        self.delayedAt(timestamp, function(error, tasks, rTimestamp){\n          if(error){ return done(error); }\n          results[(rTimestamp * 1000)] = tasks;\n          done();\n        });\n      });\n    });\n\n    async.series(jobs, function(error){\n      return callback(error, results);\n    });\n  });\n};\n\nqueue.prototype.locks = function(callback){\n  var self = this;\n  var keys = [];\n  var data = {};\n  var jobs = [];\n\n  jobs.push(function(done){\n    self.connection.redis.keys(self.connection.key('lock:*'), function(error, _keys){\n      if(error){ return done(error); }\n      keys = keys.concat(_keys);\n      done();\n    });\n  });\n\n  jobs.push(function(done){\n    self.connection.redis.keys(self.connection.key('workerslock:*'), function(error, _keys){\n      if(error){ return done(error); }\n      keys = keys.concat(_keys);\n      done();\n    });\n  });\n\n  async.parallel(jobs, function(error){\n    if(error){ return callback(error); }\n    if(keys.length === 0){ return callback(null, data); }\n\n    self.connection.redis.mget(keys, function(error, values){\n      if(error){ return callback(error); }\n\n      for(var i = 0; i < keys.length; i++){\n        var k = keys[i];\n        k = k.replace(self.connection.key(''), '');\n        data[k] = values[i];\n      }\n\n      callback(null, data);\n    });\n  });\n};\n\nqueue.prototype.delLock = function(key, callback){\n  var self = this;\n  self.connection.redis.del(self.connection.key(key), callback);\n};\n\nqueue.prototype.workers = function(callback){\n  var self = this;\n  var workers = {};\n  self.connection.redis.smembers(self.connection.key('workers'), function(error, results){\n    if(!error && results){\n      results.forEach(function(r){\n        var parts = r.split(':');\n        var name;\n        var queues;\n        if(parts.length === 1){\n          name = parts[0];\n          workers[name] = null;\n        }\n        else if(parts.length === 2){\n          name = parts[0];\n          queues = parts[1];\n          workers[name] = queues;\n        }else{\n          name = parts.shift() + ':' + parts.shift();\n          queues = parts.join(':');\n          workers[name] = queues;\n        }\n      });\n    }\n\n    return callback(error, workers);\n  });\n};\n\nqueue.prototype.workingOn = function(workerName, queues, callback){\n  var self = this;\n  var fullWorkerName = workerName + ':' + queues;\n  self.connection.redis.get(self.connection.key('worker', fullWorkerName), callback);\n};\n\nqueue.prototype.allWorkingOn = function(callback){\n  var self = this;\n  var results = {};\n  var jobs = [];\n\n  self.workers(function(error, workers){\n    if(error){ return callback(error); }\n\n    Object.keys(workers).forEach(function(w){\n      jobs.push(function(done){\n        results[w] = 'started';\n        self.workingOn(w, workers[w], function(error, data){\n          if(error){ return done(error); }\n          if(data){\n            data = JSON.parse(data);\n            results[data.worker] = data;\n          }\n          done();\n        });\n      });\n    });\n\n    async.series(jobs, function(error){\n      return callback(error, results);\n    });\n  });\n};\n\nqueue.prototype.forceCleanWorker = function(workerName, callback){\n  var self = this;\n  var errorPayload;\n  var jobs = [];\n\n  self.workers(function(error, workers){\n    if(error){ return callback(error); }\n    var queues = workers[workerName];\n    if(!queues){ return callback(new Error('worker not round')); }\n\n    self.workingOn(workerName, queues, function(error, workingOn){\n      if(error){ return callback(error); }\n      if(workingOn){\n        workingOn = JSON.parse(workingOn);\n        errorPayload = {\n          worker: workerName,\n          queue: workingOn.queue,\n          payload: workingOn.payload,\n          exception: 'Worker Timeout (killed manually)',\n          error: 'Worker Timeout (killed manually)',\n          backtrace: null,\n          failed_at: (new Date()).toString()\n        };\n\n        jobs.push(function(done){\n          self.connection.redis.incr(self.connection.key('stat', 'failed'), done);\n        });\n\n        jobs.push(function(done){\n          self.connection.redis.incr(self.connection.key('stat', 'failed', workerName), done);\n        });\n\n        jobs.push(function(done){\n          self.connection.redis.rpush(self.connection.key('failed'), JSON.stringify(errorPayload), done);\n        });\n      }\n\n      jobs.push(function(done){\n        self.connection.redis.del(self.connection.key('stat', 'failed', workerName), done);\n      });\n\n      jobs.push(function(done){\n        self.connection.redis.del(self.connection.key('stat', 'processed', workerName), done);\n      });\n\n      jobs.push(function(done){\n        self.connection.redis.del(self.connection.key('worker', workerName), done);\n      });\n\n      jobs.push(function(done){\n        self.connection.redis.srem(self.connection.key('workers'), workerName + ':' + queues, done);\n      });\n\n      async.series(jobs, function(error){\n        return callback(error, errorPayload);\n      });\n    });\n  });\n};\n\nqueue.prototype.cleanOldWorkers = function(age, callback){\n  // note: this method will remove the data created by a 'stuck' worker and move the payload to the error queue\n  // however, it will not actually remove any processes which may be running.  A job *may* be running that you have removed\n\n  var self = this;\n  var results = {};\n  var jobs = [];\n\n  self.allWorkingOn(function(error, data){\n    if(error){ return callback(error); }\n\n    Object.keys(data).forEach(function(workerName){\n      jobs.push(function(done){\n        if(Date.now() - Date.parse(data[workerName].run_at) > age){\n          self.forceCleanWorker(workerName, function(error, errorPayload){\n            if(errorPayload && errorPayload.worker){ results[errorPayload.worker] = errorPayload; }\n            done(error);\n          });\n        }else{\n          done();\n        }\n      });\n    });\n\n    async.series(jobs, function(error){\n      return callback(error, results);\n    });\n  });\n};\n\nqueue.prototype.failedCount = function(callback){\n  var self = this;\n  self.connection.redis.llen(self.connection.key('failed'), callback);\n};\n\nqueue.prototype.failed = function(start, stop, callback){\n  var self = this;\n  self.connection.redis.lrange(self.connection.key('failed'), start, stop, function(error, data){\n    var results = data.map(function(i){ return JSON.parse(i); });\n    callback(error, results);\n  });\n};\n\nqueue.prototype.removeFailed = function(failedJob, callback){\n  var self = this;\n  self.connection.redis.lrem(self.connection.key('failed'), 1, JSON.stringify(failedJob), callback);\n};\n\nqueue.prototype.retryAndRemoveFailed = function(failedJob, callback){\n  var self = this;\n  self.removeFailed(failedJob, function(error, countFailed){\n    if(error){ return callback(error, failedJob); }\n    if(countFailed < 1){ return callback(new Error('This job is not in failed queue'), failedJob); }\n    self.enqueue(failedJob.queue, failedJob.payload['class'], failedJob.payload.args, callback);\n  });\n};\n\nqueue.prototype.stats = function(callback){\n  var self = this;\n  self.connection.redis.keys(self.connection.key('stat:*'), function(error, keys){\n    if(error){ return callback(error); }\n    if(keys.length === 0){ return callback(); }\n\n    self.connection.redis.mget(keys, function(error, values){\n      if(error){ return callback(error); }\n\n      var data = {};\n      for(var i = 0; i < keys.length; i++){\n        var k = keys[i];\n        k = k.replace(self.connection.key('stat:'), '');\n        data[k] = values[i];\n      }\n\n      callback(null, data);\n    });\n  });\n};\n\n/////////////\n// HELPERS //\n/////////////\n\nvar arrayify = function(o){\n  if(Array.isArray(o)){\n    return o;\n  }else{\n    return [o];\n  }\n};\n\nexports.queue = queue;\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/pluginRunner.js":"var runPlugin = function(self, pluginRefrence, type, func, queue, job, args, callback){\n  process.nextTick(function(){\n    if(!job){\n      callback(null, true);\n    }else{\n\n      var pluginName = pluginRefrence;\n      if(typeof pluginRefrence === 'function'){\n        pluginName = new pluginRefrence(self, func, queue, job, args, {}).name;\n      }\n\n      var pluginOptions = null;\n      if(self.jobs[func].pluginOptions && self.jobs[func].pluginOptions[pluginName]){\n        pluginOptions = self.jobs[func].pluginOptions[pluginName];\n      }else{\n        pluginOptions = {};\n      }\n\n      var plugin = null;\n      if(typeof pluginRefrence === 'string'){\n        var pluginConstructor = require(__dirname + '/plugins/' + pluginRefrence + '.js')[pluginRefrence];\n        plugin = new pluginConstructor(self, func, queue, job, args, pluginOptions);\n      }else if(typeof pluginRefrence === 'function'){\n        plugin = new pluginRefrence(self, func, queue, job, args, pluginOptions);\n      }else{\n        throw new Error('Plugin must be the constructor name or an object');\n      }\n\n      if(plugin[type] === null || plugin[type] === undefined  || typeof plugin[type] !== 'function'){\n        callback(null, true);\n      }else{\n        plugin[type](function(err, toRun){\n          callback(err, toRun);\n        });\n      }\n    }\n  });\n};\n\nvar runPlugins = function(self, type, func, queue, job, args, callback, pluginCounter){\n  if(!pluginCounter){ pluginCounter = 0; }\n  if(!job){\n    callback(null, true);\n  }else if(job.plugins === null || job.plugins === undefined || job.plugins.length === 0){\n    callback(null, true);\n  }else if(pluginCounter >= job.plugins.length){\n    callback(null, true);\n  }else{\n    var pluginRefrence = job.plugins[pluginCounter];\n    runPlugin(self, pluginRefrence, type, func, queue, job, args, function(err, toRun){\n      pluginCounter++;\n      if(err){\n        callback(err, toRun);\n      }else if(toRun === false){\n        callback(err, false);\n      }else{\n        runPlugins(self, type, func, queue, job, args, callback, pluginCounter);\n      }\n    });\n  }\n};\n\nexports.runPlugin = runPlugin;\nexports.runPlugins = runPlugins;\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/worker.js":"var os = require('os');\nvar util = require('util');\nvar async = require('async');\nvar exec = require('child_process').exec;\nvar EventEmitter = require('events').EventEmitter;\nvar connection   = require(__dirname + '/connection.js').connection;\nvar queue        = require(__dirname + '/queue.js').queue;\nvar pluginRunner = require(__dirname + '/pluginRunner.js');\n\nvar worker = function(options, jobs){\n  var self = this;\n  if(!jobs){ jobs = {}; }\n\n  var defaults = self.defaults();\n  for(var i in defaults){\n    if(options[i] === undefined || options[i] === null){\n      options[i] = defaults[i];\n    }\n  }\n\n  self.options = options;\n  self.jobs = prepareJobs(jobs);\n  self.name = self.options.name;\n  self.queues = self.options.queues;\n  self.error = null;\n  self.result = null;\n  self.ready = false;\n  self.running = false;\n  self.working = false;\n  self.job = null;\n\n  self.queueObject = new queue({connection: options.connection}, self.jobs);\n\n  self.queueObject.on('error', function(error){\n    self.emit('error', null, null, error);\n  });\n};\n\nutil.inherits(worker, EventEmitter);\n\nworker.prototype.defaults = function(){\n  var self = this;\n  return {\n    name:      os.hostname() + ':' + process.pid, // assumes only one worker per node process\n    queues:    '*',\n    timeout:   5000,\n    looping:   true,\n  };\n};\n\nworker.prototype.connect = function(callback){\n  var self = this;\n  self.queueObject.connect(function(){\n    self.connection = self.queueObject.connection;\n    self.checkQueues(function(){\n      if(typeof callback === 'function'){ callback(); }\n    });\n  });\n};\n\nworker.prototype.start = function(){\n  var self = this;\n  if(self.ready){\n    self.emit('start');\n    self.init(function(){\n      self.poll();\n    });\n  }\n};\n\nworker.prototype.end = function(callback){\n  var self = this;\n  self.running = false;\n  if(self.working === true){\n    setTimeout(function(){\n      self.end(callback);\n    }, self.options.timeout);\n  }else{\n    self.untrack(self.name, self.stringQueues(), function(error){\n      self.queueObject.end(function(error){\n        self.emit('end');\n        if(typeof callback === 'function'){ callback(error); }\n      });\n    });\n  }\n};\n\nworker.prototype.poll = function(nQueue, callback){\n  var self = this;\n  if(nQueue === null || nQueue === undefined){\n    nQueue = 0;\n  }\n  if(!self.running){\n    if(typeof callback === 'function'){ callback(); }\n  }else{\n    self.queue = self.queues[nQueue];\n    self.emit('poll', self.queue);\n    if(self.queue === null || self.queue === undefined){\n      self.checkQueues(function(){\n        self.pause();\n      });\n    }else if(self.working === true){\n      var error = new Error('refusing to get new job, already working');\n      self.emit('error', self.queue, null, error);\n    }else{\n      self.working = true;\n      self.connection.redis.lpop(self.connection.key('queue', self.queue), function(error, resp){\n        if(!error && resp){\n          var currentJob = JSON.parse(resp.toString());\n          if(self.options.looping){\n            self.result = null;\n            self.perform(currentJob);\n          }else{\n            if(typeof callback === 'function'){ callback(currentJob); }\n          }\n        }else{\n          if(error){\n            self.emit('error', self.queue, null, error);\n          }\n          self.working = false;\n          if(nQueue === self.queues.length - 1){\n            process.nextTick(function(){\n              if(self.options.looping){\n                self.pause();\n              }else{\n                if(typeof callback === 'function'){ callback(); }\n              }\n            });\n          }else{\n            process.nextTick(function(){\n              self.poll(nQueue + 1, callback);\n            });\n          }\n        }\n      });\n    }\n  }\n};\n\nworker.prototype.perform = function(job, callback){\n  var self = this;\n  var returnCounter = 0; // a state counter to prevent multiple returns from poor jobs or plugins\n  var callbackError = new Error('refusing to continue with job, multiple callbacks detected');\n  self.job = job;\n  self.error = null;\n  if(!self.jobs[job['class']]){\n    self.error = new Error('No job defined for class \"' + job['class'] + '\"');\n    self.completeJob(true, callback);\n  }else{\n    var cb = self.jobs[job['class']].perform;\n    self.emit('job', self.queue, job);\n\n    if(cb){\n      pluginRunner.runPlugins(self, 'before_perform', job['class'], self.queue, self.jobs[job['class']], job.args, function(err, toRun){\n        returnCounter++;\n        if(returnCounter !== 1){\n          self.emit('failure', self.queue, job, callbackError);\n        }else if(toRun === false){\n          self.completeJob(false, callback);\n        }else{\n          self.error = err;\n          self.workingOn(job);\n          var args;\n          if(job.args === undefined || (job.args instanceof Array) === true){\n            args = job.args;\n          }else{\n            args = [job.args];\n          }\n\n          var combinedInputs = [].slice.call(args).concat([function(err, result){\n            returnCounter++;\n            if(returnCounter !== 2){\n              self.emit('failure', self.queue, job, callbackError);\n            }else{\n              self.error = err;\n              self.result = result;\n              pluginRunner.runPlugins(self, 'after_perform', job['class'], self.queue, self.jobs[job['class']], job.args, function(e, toRun){\n                if(self.error === undefined && e){ self.error = e; }\n                returnCounter++;\n                if(returnCounter !== 3){\n                  self.emit('failure', self.queue, job, callbackError);\n                }else{\n                  self.completeJob(true, callback);\n                }\n              });\n            }\n          }]);\n\n          // When returning the payload back to redis (on error), it is important that the orignal payload is preserved\n          // To help with this, we can stry to make the inputs to the job immutible\n          // https://github.com/taskrabbit/node-resque/issues/99\n          // Note: if an input is a string or a number, you CANNOT freeze it saddly.\n          for(var i in combinedInputs){\n            if((typeof combinedInputs[i] === 'object') && (combinedInputs[i] !== null)){\n              Object.freeze(combinedInputs[i]);\n            }\n          }\n\n          cb.apply(self, combinedInputs);\n        }\n      });\n\n    }else{\n\n      self.error = new Error('Missing Job: ' + job['class']);\n      self.completeJob(true, callback);\n    }\n  }\n};\n\n// #performInline is used to run a job payload directly.\n// If you are planning on running a job via #performInline, this worker should also not be started, nor should be using event emitters to monitor this worker.\n// This method will also not write to redis at all, including logging errors, modify resque's stats, etc.\nworker.prototype.performInline = function(func, args, callback){\n  var self          = this;\n  var q             = '_direct-queue-' + self.name;\n  var returnCounter = 0; // a state counter to prevent multiple returns from poor jobs or plugins\n  var callbackError = new Error('refusing to continue with job, multiple callbacks detected');\n\n  if(args !== undefined && args !== null && args instanceof Array !== true){\n    args = [args];\n  }\n\n  if(!self.jobs[func]){         return callback(new Error('No job defined for class \"' + func + '\"')); }\n  if(!self.jobs[func].perform){ return callback(new Error('Missing Job: ' + func));                    }\n\n  pluginRunner.runPlugins(self, 'before_perform', func, q, self.jobs[func], args, function(err, toRun){\n    returnCounter++;\n    if(err){ return callback(err); }\n    if(returnCounter !== 1){ return callback(callbackError); }\n    if(toRun === false){ return callback(); }\n\n    var combinedInputs = [].slice.call(args).concat([function(err, result){\n      self.result = result;\n      self.error = err;\n      returnCounter++;\n      if(err){ return callback(err); }\n      if(returnCounter !== 2){ return callback(callbackError); }\n\n      pluginRunner.runPlugins(self, 'after_perform', func, q, self.jobs[func], args, function(err, toRun){\n        returnCounter++;\n        if(err){ return callback(err); }\n        if(returnCounter !== 3){ return callback(callbackError); }\n        return callback(null, result);\n      });\n    }]);\n\n    self.jobs[func].perform.apply(self, combinedInputs);\n  });\n\n};\n\nworker.prototype.completeJob = function(toRespond, callback){\n  var self = this;\n  var job = self.job;\n  var jobs = [];\n\n  if(self.error){\n    jobs.push(function(done){\n      self.fail(self.error, done);\n    });\n  }else if(toRespond){\n    jobs.push(function(done){\n      self.succeed(job, done);\n    });\n  }\n\n  jobs.push(function(done){\n    self.doneWorking(done);\n  });\n\n  async.series(jobs, function(error){\n    if(error){ self.emit('error', null, null, error); }\n    self.job = null;\n\n    if(self.options.looping){\n      return self.poll();\n    }else if(typeof callback === 'function'){\n      return callback(error);\n    }\n  });\n};\n\nworker.prototype.succeed = function(job, callback){\n  var self = this;\n  var jobs = [];\n\n  jobs.push(function(done){\n    self.connection.redis.incr(self.connection.key('stat', 'processed'), done);\n  });\n\n  jobs.push(function(done){\n    self.connection.redis.incr(self.connection.key('stat', 'processed', self.name), done);\n  });\n\n  async.series(jobs, function(error){\n    if(error){ self.emit('error', null, null, error); }\n    else{ self.emit('success', self.queue, job, self.result); }\n\n    if(typeof callback === 'function'){ return callback(); }\n  });\n};\n\nworker.prototype.fail = function(err, callback){\n  var self = this;\n  var jobs = [];\n  var failingJob = self.job;\n\n  jobs.push(function(done){\n    self.connection.redis.incr(self.connection.key('stat', 'failed'), done);\n  });\n\n  jobs.push(function(done){\n    self.connection.redis.incr(self.connection.key('stat', 'failed', self.name), done);\n  });\n\n  jobs.push(function(done){\n    self.connection.redis.rpush(self.connection.key('failed'), JSON.stringify(self.failurePayload(err, failingJob)), done);\n  });\n\n  async.series(jobs, function(error){\n    if(error){\n      self.emit('error', null, null, error);\n      if(typeof callback === 'function'){ return callback(error); }\n    }else{\n      self.emit('failure', self.queue, failingJob, err);\n      if(typeof callback === 'function'){ return callback(); }\n    }\n  });\n};\n\nworker.prototype.pause = function(){\n  var self = this;\n  self.emit('pause');\n  setTimeout(function(){\n    if(!self.running){ return; }\n    self.poll();\n  }, self.options.timeout);\n};\n\nworker.prototype.workingOn = function(job){\n  var self = this;\n  self.connection.redis.set(self.connection.key('worker', self.name, self.stringQueues()), JSON.stringify({\n    run_at: (new Date()).toString(),\n    queue: self.queue,\n    payload: job,\n    worker: self.name,\n  }));\n};\n\nworker.prototype.doneWorking = function(callback){\n  var self = this;\n  self.working = false;\n  self.connection.redis.del(self.connection.key('worker', self.name, self.stringQueues()), callback);\n};\n\nworker.prototype.track = function(callback){\n  var self = this;\n  self.running = true;\n  self.connection.redis.sadd(self.connection.key('workers'), (self.name + ':' + self.stringQueues()), function(error){\n    if(error){ self.emit('error', null, null, error); }\n    if(typeof callback === 'function'){ callback(error); }\n  });\n};\n\nworker.prototype.untrack = function(name, queues, callback){\n  var self = this;\n  var jobs = [];\n\n  if(self.connection && self.connection.redis){\n    self.connection.redis.srem(self.connection.key('workers'), (name + ':' + queues), function(error){\n      if(error){\n        self.emit('error', null, null, error);\n        if(typeof callback === 'function'){ callback(error); }\n        return;\n      }\n\n      [\n        self.connection.key('worker', name, self.stringQueues()),\n        self.connection.key('worker', name, self.stringQueues(), 'started'),\n        self.connection.key('stat', 'failed', name),\n        self.connection.key('stat', 'processed', name)\n      ].forEach(function(key){\n        jobs.push(function(done){ self.connection.redis.del(key, done); });\n      });\n\n      async.series(jobs, function(error){\n        if(error){ self.emit('error', null, null, error); }\n        if(typeof callback === 'function'){ callback(error); }\n      });\n    });\n  }else{\n    callback();\n  }\n};\n\nworker.prototype.init = function(callback){\n  var self = this;\n  var args;\n  var _ref;\n  self.track(function(error){\n    if(error){\n      self.emit('error', null, null, error);\n      if(typeof callback === 'function'){ callback(error); }\n      return;\n    }\n\n    self.connection.redis.set(self.connection.key('worker', self.name, self.stringQueues(), 'started'), Math.round((new Date()).getTime() / 1000), function(error){\n      if(error){ self.emit('error', null, null, error); }\n      if(typeof callback === 'function'){ callback(error); }\n    });\n  });\n};\n\nworker.prototype.workerCleanup = function(callback){\n  var self = this;\n  var jobs = [];\n  self.getPids(function(error, pids){\n    if(error){\n      self.emit('error', null, null, error);\n      if(typeof callback === 'function'){ callback(error); }\n      return;\n    }\n\n    self.connection.redis.smembers(self.connection.key('workers'), function(error, workers){\n      if(error){\n        if(typeof callback === 'function'){ callback(error); }\n        else{ self.emit('error', null, null, error); }\n        return;\n      }\n\n      workers.forEach(function(w){\n        var parts = w.split(':');\n        var host = parts[0]; var pid = parseInt(parts[1]); var queues = parseInt(parts[2]);\n        if(host === os.hostname() && pids.indexOf(pid) < 0){\n          jobs.push(function(done){\n            self.emit('cleaning_worker', w, pid);\n            var parts = w.split(':');\n            var queues = parts.splice(-1, 1);\n            var pureName = parts.join(':');\n            self.untrack(pureName, queues, done);\n          });\n        }\n      });\n\n      async.series(jobs, function(error){\n        if(error){ self.emit('error', null, null, error); }\n        if(typeof callback === 'function'){ callback(error); }\n      });\n    });\n  });\n};\n\nworker.prototype.getPids = function(callback){\n  var cmd;\n  if(process.platform === 'win32'){\n    cmd = 'for /f \"usebackq tokens=2 skip=2\" %i in (`tasklist /nh`) do @echo %i';\n  }else{\n    cmd = 'ps -ef | awk \\'{print $2}\\'';\n  }\n\n  var child = exec(cmd, function(error, stdout, stderr){\n    var pids = [];\n    stdout.split('\\n').forEach(function(line){\n      line = line.trim();\n      if(line.length > 0){\n        var pid = parseInt(line.split(' ')[0]);\n        if(!isNaN(pid)){ pids.push(pid); }\n      }\n    });\n\n    if(!error && stderr){ error = stderr; }\n    callback(error, pids);\n  });\n};\n\nworker.prototype.checkQueues = function(callback){\n  var self = this;\n  if(typeof self.queues === 'string'){\n    self.queues = [self.queues];\n  }\n  if(self.ready === true && self.queues.length > 0 && self.queues.shift){\n    return;\n  }\n\n  if((self.queues[0] === '*' && self.queues.length === 1) || self.queues.length === 0){\n    self.originalQueue = '*';\n    self.untrack(self.name, self.stringQueues(), function(error){\n      if(error){\n        self.emit('error', null, null, error);\n        if(typeof callback === 'function'){ callback(error); }\n        return;\n      }\n\n      self.connection.redis.smembers(self.connection.key('queues'), function(error, resp){\n        if(error){\n          self.emit('error', null, null, error);\n          if(typeof callback === 'function'){ callback(error); }\n          return;\n        }\n\n        self.queues = resp ? resp.sort() : [];\n        self.track(function(error){\n          if(error){ self.emit('error', null, null, error); }\n          self.ready = true;\n          if(typeof callback === 'function'){ callback(error); }\n        });\n      });\n    });\n  }else{\n    if(self.queues instanceof String){ self.queues = self.queues.split(','); }\n    self.ready = true;\n    if(typeof callback === 'function'){ callback(); }\n  }\n};\n\nworker.prototype.failurePayload = function(err, job){\n  var self = this;\n  return {\n    worker: self.name,\n    queue: self.queue,\n    payload: job,\n    exception: err.name,\n    error: err.message,\n    backtrace: err.stack ? err.stack.split('\\n').slice(1) : null,\n    failed_at: (new Date()).toString()\n  };\n};\n\nworker.prototype.stringQueues = function(){\n  var self = this;\n  if(self.queues.length === 0){\n    return ['*'].join(',');\n  }else{\n    try{\n      return self.queues.join(',');\n    }catch(e){\n      return '';\n    }\n  }\n};\n\nfunction prepareJobs(jobs){\n  return Object.keys(jobs).reduce(function(h, k){\n    var job = jobs[k];\n    h[k] = typeof job === 'function' ? { perform: job } : job;\n    return h;\n  }, {});\n}\n\nexports.worker = worker;\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/multiWorker.js":"var os = require('os');\nvar util = require('util');\nvar async = require('async');\nvar EventEmitter = require('events').EventEmitter;\nvar Worker = require(__dirname + '/worker.js').worker;\nvar eventLoopDelay = require(__dirname + '/eventLoopDelay');\n\nvar multiWorker = function(options, jobs){\n  var self = this;\n\n  var defaults = self.defaults();\n  for(var i in defaults){\n    if(options[i] === null || options[i] === undefined){\n      options[i] = defaults[i];\n    }\n  }\n\n  if(options.connection.redis && typeof options.connection.redis.setMaxListeners === 'function'){\n    options.connection.redis.setMaxListeners(options.connection.redis.getMaxListeners() + options.maxTaskProcessors);\n  }\n\n  self.workers = [];\n  self.options = options;\n  self.jobs = jobs;\n  self.running = false;\n  self.working = false;\n  self.name = self.options.name;\n  self.eventLoopBlocked = true;\n  self.eventLoopDelay = Infinity;\n  self.eventLoopCheckCounter = 0;\n\n  eventLoopDelay(\n    self.options.maxEventLoopDelay,\n    self.options.checkTimeout,\n  function(blocked, ms){\n    self.eventLoopBlocked = blocked;\n    self.eventLoopDelay = ms;\n    self.eventLoopCheckCounter++;\n  });\n};\n\nutil.inherits(multiWorker, EventEmitter);\n\nmultiWorker.prototype.defaults = function(){\n  var self = this;\n  // all times in ms\n  return {\n    minTaskProcessors:   1,\n    maxTaskProcessors:   10,\n    timeout:             5000,\n    checkTimeout:        500,\n    maxEventLoopDelay:   10,\n    toDisconnectProcessors: true,\n    name: os.hostname()\n  };\n};\n\nmultiWorker.prototype.startWorker = function(callback){\n  var self = this;\n  var id = (self.workers.length + 1);\n  var worker = new Worker({\n    connection: self.options.connection,\n    queues:     self.options.queues,\n    timeout:    self.options.timeout,\n    name:       self.options.name + ':' + process.pid + '+' + id\n  }, self.jobs);\n  worker.connect(function(error){\n    if(error){ self.emit('error', error); }\n    worker.workerCleanup(function(error){\n      worker.start();\n      if(error){ self.emit('error', error); }\n      process.nextTick(callback);\n    });\n  });\n\n  worker.id = id;\n\n  worker.on('start',           function(){                    self.emit('start', worker.id);                         });\n  worker.on('end',             function(){                    self.emit('end', worker.id);                           });\n  worker.on('cleaning_worker', function(worker, pid){         self.emit('cleaning_worker', worker.id, worker, pid);  });\n  worker.on('poll',            function(queue){               self.emit('poll', worker.id, queue);                   });\n  worker.on('job',             function(queue, job){          self.emit('job', worker.id, queue, job);               });\n  worker.on('reEnqueue',       function(queue, job, plugin){  self.emit('reEnqueue', worker.id, queue, job, plugin); });\n  worker.on('success',         function(queue, job, result){  self.emit('success', worker.id, queue, job, result);   });\n  worker.on('failure',         function(queue, job, failure){ self.emit('failure', worker.id, queue, job, failure);  });\n  worker.on('error',           function(queue, job, error){   self.emit('error', worker.id, queue, job, error);      });\n  worker.on('pause',           function(){                    self.emit('pause', worker.id);                         });\n\n  self.workers.push(worker);\n};\n\nmultiWorker.prototype.checkWorkers = function(callback){\n  var self = this;\n  var verb;\n  var workingCount = 0;\n\n  setImmediate(function(){\n\n    self.workers.forEach(function(worker){\n      if(worker.working === true){ workingCount++; }\n    });\n\n    if(workingCount > 0){\n      self.working = true;\n    }else{\n      self.working = false;\n    }\n\n    if(self.running === false && self.workers.length > 0){                                     verb = '--'; }\n    else if(self.running === false && self.workers.length === 0){                              verb = 'x';  }\n    else if(self.eventLoopBlocked  && self.workers.length > self.options.minTaskProcessors){   verb = '-';  }\n    else if(self.eventLoopBlocked  && self.workers.length === self.options.minTaskProcessors){ verb = 'x';  }\n    else if(!self.eventLoopBlocked && self.workers.length < self.options.minTaskProcessors){   verb = '+';  }\n    else if(\n      !self.eventLoopBlocked &&\n      self.workers.length < self.options.maxTaskProcessors &&\n      (\n        self.workers.length === 0 ||\n        workingCount / self.workers.length > 0.5\n      )\n    ){ verb = '+'; }\n    else if(\n      !self.eventLoopBlocked &&\n      self.workers.length > self.options.minTaskProcessors &&\n      workingCount / self.workers.length < 0.5\n    ){\n      verb = '-';\n    }\n    else{ verb = 'x'; }\n\n    if(verb === 'x'){ return callback(null, verb, self.eventLoopDelay); }\n\n    if(verb === '-'){\n      var worker = self.workers.pop();\n      worker.end(function(error){\n        self.cleanupWorker(worker);\n        return callback(error, verb, self.eventLoopDelay);\n      });\n    }\n\n    if(verb === '--'){\n      var jobs = [];\n\n      var stopWorker = function(worker){\n        jobs.push(function(done){\n          worker.end(function(error){\n            if(error){ return done(error); }\n            self.cleanupWorker(worker);\n            done();\n          });\n        });\n      };\n\n      while(self.workers.length > 0){\n        var worker = self.workers.pop();\n        stopWorker(worker);\n      }\n\n      async.parallel(jobs, function(error){\n        self.workers = [];\n        callback(error, verb, self.eventLoopDelay);\n      });\n    }\n\n    if(verb === '+'){\n      self.startWorker(function(error){\n        callback(error, verb, self.eventLoopDelay);\n      });\n    }\n  });\n};\n\nmultiWorker.prototype.cleanupWorker = function(worker){\n  var self = this;\n\n  [\n    'start',\n    'end',\n    'cleaning_worker',\n    'poll',\n    'job',\n    'reEnqueue',\n    'success',\n    'failure',\n    'error',\n    'pause',\n    'internalError',\n    'multiWorkerAction',\n  ].forEach(function(e){\n    worker.removeAllListeners(e);\n  });\n\n  if(self.options.toDisconnectProcessors === true){\n    worker.connection.end();\n  }\n};\n\nmultiWorker.prototype.checkWraper = function(callback){\n  var self = this;\n  clearTimeout(self.checkTimer);\n  self.checkWorkers(function(error, verb, delay){\n    if(error){ self.emit('internalError', error); }\n    self.emit('multiWorkerAction', verb, delay);\n    self.checkTimer = setTimeout(function(){\n      self.checkWraper();\n    }, self.options.checkTimeout);\n    if(typeof callback === 'function'){ callback(); }\n  });\n};\n\nmultiWorker.prototype.start = function(callback){\n  var self = this;\n  self.running = true;\n  self.checkWraper(function(){\n    if(typeof callback === 'function'){ callback(); }\n  });\n};\n\nmultiWorker.prototype.stop = function(callback){\n  var self = this;\n  self.running = false;\n  self.stopWait(callback);\n};\n\nmultiWorker.prototype.end = function(callback){\n  var self = this;\n  self.stop(callback);\n};\n\nmultiWorker.prototype.stopWait = function(callback){\n  var self = this;\n  if(self.workers.length === 0 && self.working === false){\n    clearTimeout(self.checkTimer);\n    process.nextTick(function(){\n      if(typeof callback === 'function'){ callback(); }\n    });\n  }else{\n    setTimeout(function(){\n      self.stopWait(callback);\n    }, self.options.checkTimeout);\n  }\n};\n\nexports.multiWorker = multiWorker;\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/eventLoopDelay.js":"// inspired by https://github.com/tj/node-blocked\n\nmodule.exports = function(limit, interval, fn){\n  var start = process.hrtime();\n\n  var timeout = setInterval(function(){\n    var delta = process.hrtime(start);\n    var nanosec = delta[0] * 1e9 + delta[1];\n    var ms = nanosec / 1e6;\n    var n = ms - interval;\n    if(n > limit){\n      fn(true, Math.round(n));\n    }else{\n      fn(false, Math.round(n));\n    }\n    start = process.hrtime();\n  }, interval);\n\n  if(timeout.unref){\n    timeout.unref();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-resque/node_modules/node-resque/lib/scheduler.js":"// To read notes about the master locking scheme, check out:\n//   https://github.com/resque/resque-scheduler/blob/master/lib/resque/scheduler/locking.rb\n\nvar EventEmitter = require('events').EventEmitter;\nvar util         = require('util');\nvar os           = require('os');\nvar connection   = require(__dirname + '/connection.js').connection;\nvar queue        = require(__dirname + '/queue.js').queue;\n\nvar scheduler = function(options, jobs){\n  var self = this;\n  if(!jobs){ jobs = {}; }\n  var defaults = self.defaults();\n\n  for(var i in defaults){\n    if(options[i] === null || options[i] === undefined){\n      options[i] = defaults[i];\n    }\n  }\n\n  self.options    = options;\n  self.name       = self.options.name;\n  self.master     = false;\n  self.running    = false;\n  self.processing = false;\n\n  self.queue = new queue({connection: options.connection}, jobs);\n\n  self.queue.on('error', function(error){\n    self.emit('error', error);\n  });\n};\n\nutil.inherits(scheduler, EventEmitter);\n\nscheduler.prototype.defaults = function(){\n  var self = this;\n  return {\n    timeout:           5000,   // in ms\n    masterLockTimeout: 60 * 3, // in seconds\n    name:              os.hostname() + ':' + process.pid, // assumes only one worker per node process\n  };\n};\n\nscheduler.prototype.connect = function(callback){\n  var self = this;\n  self.queue.connect(function(){\n    self.connection = self.queue.connection;\n    if(typeof callback === 'function'){ callback(); }\n  });\n};\n\nscheduler.prototype.start = function(){\n  var self = this;\n  self.processing = false;\n\n  if(!self.running){\n    self.emit('start');\n    self.running = true;\n    self.timer = setTimeout((function(){\n      self.poll();\n    }), self.options.timeout);\n  }\n};\n\nscheduler.prototype.end = function(callback){\n  var self = this;\n  self.running = false;\n  clearTimeout(self.timer);\n\n  if(self.processing === false){\n    self.releaseMasterLock(function(error, wasMaster){\n      if(error){ self.emit('error', error); }\n      self.queue.end(function(){\n        self.emit('end');\n        process.nextTick(function(){\n          if(typeof callback === 'function'){ callback(); }\n        });\n      });\n    });\n  }\n\n  else{\n    setTimeout(function(){\n      self.end(callback);\n    }, (self.options.timeout / 2));\n  }\n};\n\nscheduler.prototype.poll = function(callback){\n  var self = this;\n  self.processing = true;\n  clearTimeout(self.timer);\n  self.tryForMaster(function(error, isMaster){\n    if(error){ self.emit('error', error); }\n    if(isMaster){\n      if(!self.master){\n        self.master = true;\n        self.emit('master');\n      }\n      self.emit('poll');\n      self.nextDelayedTimestamp(function(error, timestamp){\n        if(!error && timestamp){\n          self.emit('working_timestamp', timestamp);\n          self.enqueueDelayedItemsForTimestamp(timestamp, function(error){\n            if(error){ self.emit('error', error); }\n            self.poll(callback);\n          });\n        }else{\n          if(error){ self.emit('error', error); }\n          self.processing = false;\n          self.pollAgainLater();\n          if(typeof callback === 'function'){ callback(); }\n        }\n      });\n    }else{\n      self.master = false;\n      self.processing = false;\n      self.pollAgainLater();\n      if(typeof callback === 'function'){ callback(); }\n    }\n  });\n};\n\nscheduler.prototype.pollAgainLater = function(){\n  var self = this;\n  if(self.running === true){\n    self.timer = setTimeout(function(){\n      self.poll();\n    }, self.options.timeout);\n  }\n};\n\nscheduler.prototype.masterKey = function(){\n  var self = this;\n  return self.connection.key('resque_scheduler_master_lock');\n};\n\nscheduler.prototype.tryForMaster = function(callback){\n  var self = this;\n\n  if(!self.connection || !self.connection.redis){\n    return callback();\n  }\n\n  self.connection.redis.setnx(self.masterKey(), self.options.name, function(error, locked){\n    if(error){ return callback(error); }\n    else if(locked === true || locked === 1){\n      self.connection.redis.expire(self.masterKey(), self.options.masterLockTimeout, function(error){\n        return callback(error, true);\n      });\n    }else{\n      self.connection.redis.get(self.masterKey(), function(error, value){\n        if(error){ return callback(error); }\n        else if(value === self.options.name){\n          self.connection.redis.expire(self.masterKey(), self.options.masterLockTimeout, function(error){\n            return callback(error, true);\n          });\n        }else{\n          return callback(null, false);\n        }\n      });\n    }\n  });\n};\n\nscheduler.prototype.releaseMasterLock = function(callback){\n  var self = this;\n  if(self.connection){\n    self.tryForMaster(function(error, isMaster){\n      if(error){ return callback(error); }\n      else if(!isMaster){ return callback(null, false); }\n      else{\n        self.connection.redis.del(self.masterKey(), function(error, delted){\n          self.master = false;\n          return callback(error, (delted === 1));\n        });\n      }\n    });\n  }else{\n    return callback();\n  }\n};\n\nscheduler.prototype.nextDelayedTimestamp = function(callback){\n  var self = this;\n  var time = Math.round(new Date().getTime() / 1000);\n  self.connection.redis.zrangebyscore(self.connection.key('delayed_queue_schedule'), '-inf', time, 'limit', 0, 1, function(error, items){\n    if(error || items === null || items.length === 0){\n      return callback(error);\n    }else{\n      return callback(null, items[0]);\n    }\n  });\n};\n\nscheduler.prototype.enqueueDelayedItemsForTimestamp = function(timestamp, callback){\n  var self = this;\n  self.nextItemForTimestamp(timestamp, function(error, job){\n    if(!error && job){\n      self.transfer(timestamp, job, function(){\n        self.enqueueDelayedItemsForTimestamp(timestamp, callback);\n      });\n    }else{\n      return callback(error);\n    }\n  });\n};\n\nscheduler.prototype.nextItemForTimestamp = function(timestamp, callback){\n  var self = this;\n  var key = self.connection.key('delayed:' + timestamp);\n  self.connection.redis.lpop(key, function(error, job){\n    if(error){\n      return callback(error);\n    }else{\n      self.connection.redis.srem(self.connection.key('timestamps:' + job), ('delayed:' + timestamp), function(error){\n        self.cleanupTimestamp(timestamp, function(){\n          if(error){\n            return callback(error);\n          }else{\n            return callback(null, JSON.parse(job));\n          }\n        });\n      });\n    }\n  });\n};\n\nscheduler.prototype.transfer = function(timestamp, job, callback){\n  var self = this;\n  self.queue.enqueue(job.queue, job['class'], job.args, function(error){\n    if(error){ self.emit('error', error); }\n    self.emit('transferred_job', timestamp, job);\n    return callback();\n  });\n};\n\nscheduler.prototype.cleanupTimestamp = function(timestamp, callback){\n  var self = this;\n  var key = self.connection.key('delayed:' + timestamp);\n  self.connection.redis.llen(key, function(error, len){\n    if(error){ return callback(error); }\n    if(len === 0){\n      self.connection.redis.del(key, function(error){\n        if(error){ return callback(error); }\n        self.connection.redis.zrem(self.connection.key('delayed_queue_schedule'), timestamp, function(error){\n          return callback(error);\n        });\n      });\n    }\n    else{ return callback(); }\n  });\n};\n\nexports.scheduler = scheduler;\n"}